<div>
In this assignment, you get to build your own implementation of an
<em>octree</em>, a hierarchical data structure that enables fast ray
intersection computations involving very large numbers of triangles.

<center>
    <img src="images/octree.png">
</center>

Each node of an octree covers an axis-aligned region of space denoted by two
points \(\mathbf{p}_\textrm{min}\) and \(\mathbf{p}_\textrm{max}\).
An interior node has exactly eight child nodes that partition this space into
eight equal-sized subregions. The region of space covered by the \(i\)-th child
of an octree-node is defined as the bounding box containing both the center and
the \(i\)-th corner of its parent (using a suitable ordering of the corners).

In the context of rendering, our goal will be to construct a tree where each
leaf node only contains a small number of triangles (e.g. less than 10). At render
time, this will allow most ray intersections to be pruned away since any ray
will only touch a small number of octree nodes. An efficient ray intersection
algorithm will then only traverse this subset of nodes until the closest
intersection is found.

<h3>Preliminaries: Updating Nori and downloading scene data</h3>

<div class="text-justify">
<p>
Since the last assignment, we may have committed a new revision to the base Nori repository.
Before continuing, merge this new revision into your current Nori codebase as follows:
<pre class="prettyprint lang-bash">
$ git pull upstream master
</pre>
There may be no new changes to pull. In rare cases, this may also trigger merge
conflicts, if the same files were modified in both revisions.
If you have difficulties with this step, refer to the git tutorials mentioned in
Assignment 1.
</p>

<p>
For this homework, we will be using the scene <code>scenes/pa2/ajax-normals.xml</code>.
This scene references the 3D scan of a bust that is fairly large (~500K triangles). Due to
its size, the actual mesh is not part of the repository and can be downloaded
<a href="//rgl.s3.eu-central-1.amazonaws.com/media/uploads/bnicolet/2022/03/01/ajax.obj">here</a>.
</p>
<div class="alert alert-danger" role="alert">
    <b>Warning</b>: For this same reason, we ask you not to commit the file to
    your repository. To make sure this doesn't happen, you can add the file
    to your repository's <code>.gitignore</code> file (located at the root).
</div>

<p>
Try rendering this new scene. You will find that rendering is <em>very</em> slow.
The reason for this is that the Nori codebase currently implements a brute
force ray intersection algorithm found in the files
<code>include/nori/accel.h</code> and <code>include/nori/accel.cpp</code>.
Our main concern is the function
</p>

<pre class="prettyprint lang-cpp">
bool rayIntersect(const Ray3f &ray, Intersection &its, bool shadowRay) const;
</pre>

<p>
which traces a ray <code>ray</code> against all triangles and stores the
resulting information in a special <code>Intersection</code> data structure.
The function returns <code>true</code> if an intersection was found and
<code>false</code> otherwise.
The parameter <code>shadowRay</code> signals to the implementation
whether a <em>shadow ray</em> is being traced. Tracing shadow rays is cheaper
since we only care about whether a ray has <em>any</em> intersections at all,
rather than searching the closest one. Furthermore, the
<code>Intersection</code> data structure does not need to be filled for shadow
rays.
</p>

<p>
Currently, the problematic part of the implementation looks as follows:
</p>

<pre class="prettyprint lang-cpp">
/* Brute force search through all triangles */
for (uint32_t idx = 0; idx < m_mesh->getTriangleCount(); ++idx) {
    float u, v, t;
    if (m_mesh->rayIntersect(idx, ray, u, v, t)) {
        /* An intersection was found! Can terminate
           immediately if this is a shadow ray query */
        if (shadowRay)
            return true;
        ray.maxt = its.t = t;
        its.uv = Point2f(u, v);
        its.mesh = m_mesh;
        f = idx;
        foundIntersection = true;
    }
}
</pre>

<p>
In the above snippet, <tt>u</tt> and <tt>v</tt> denote the barycentric coordinates
of the intersection (if it exists), and <tt>t</tt> is the distance traveled along the ray.
</p>
</div>
<div class="alert alert-info" role="alert"><b>Grading</b>: Assignments will be graded based on (1) your text answers in the report and (2) the correctness of your code implementation. In this assignment, we additionally test the efficiency of your implementation (see part 4).
Your submission will be tested on our server to recompute a consistent speedup number, which should approximately match the speedup you computed locally. A correct but inefficient implementation will not receive full marks.
</div>
<!-- ------------------------------------------------------------------------ -->
<h3>Part 1: Octree construction <em>(30 points)</em></h3>
<div class="text-justify">
<p>
Clearly, traversing 500K triangles for every ray in an image is not going to work, so we'll
need a way to organize them more intelligently.
</p>
<p>
Your objective for the first part of this assignment is to develop a tree
construction algorithm that organizes the triangle data of the scene's meshes
into an octree. At a high level, your code should look something like this:
</p>
<pre class="prettyprint lang-cpp">
Node *build(bounding box, triangles) {
    if (no triangles)
        return nullptr;

    if (only few triangles)
        return new leaf node with triangles;

    triangle_list list[8];

    for (every triangle) {
        for (int i = 0; i < 8; ++i) {
            if (triangle overlaps sub-node i)
                add to list[i];
        }
    }

    Node *node = new Node();
    for (int i = 0; i < 8; ++i)
        node.child[i] = build(bounding box of sub-node i, list[i]);
    return node;
}
</pre>
<p>
The specifics of the implementation (naming conventions, memory allocation,
choice of auxiliary data structures) are your design choices.
We'll define "few triangles" as less than 10. For simplicity, you can assume that
a triangle overlaps with an octree cell if the bounding box of the triangle's
vertices overlap with the cell.
</p>

<p>
Hint: Take a good look at <code>include/nori/bbox.h</code>. You will
find that it provides a number of functions that might come quite handy.
</p>

<p>
You may need to limit the depth of the tree to avoid pathological situations
where a triangle list can never be split into fewer than 10 elements.
</p>

<p>
Your construction code will invariably need to create a large number of
octree nodes, which will in turn occupy a considerable amount of memory. A more
compact representation that uses less memory per node will be more efficient
when tracing rays at render time, since more of the tree will fit into the
processor's cache. Think about what information truly needs to be stored, and
what information is redundant and can be recomputed on the fly.
</p>

<p>
Answer the following questions in your report:
<ol>
<li>What is a reasonable max depth of the tree? (2 pts)</li>
<li>What information do you store per octree node? (2 pts)</li>
<li>How many bytes of memory does one of your octree nodes occupy? (3 pts)</li>
<li>Compute statistics during the tree construction. For the Ajax scene, report:
    <ul>
        <li>Construction time with your local machine (not graded)</li>
        <li>Number of interior nodes (2 pts)</li>
        <li>Number of leaf nodes (2 pts)</li>
        <li>Average number of triangles per leaf node (a triangle can exist in
        multiple nodes) (2 pts)</li>
    </ul>
</li>
</ol>
</p>
</div>
<!-- ------------------------------------------------------------------------ -->
<h3>Part 2: Ray traversal <em>(15 points)</em></h3>
<div class="text-justify">
<p>
Having completed the acceleration data structure, the next step is to actually
use it to trace rays. Modify the function
</p>
<pre class="prettyprint lang-cpp">
bool rayIntersect(const Ray3f &ray, Intersection &its, bool shadowRay) const;
</pre>
<p>
so that it performs a hierarchical traversal of the tree, which only visits
octree nodes that overlap with the ray extents (in any order). Once more, take
a good look at functionality that is already provided in
<code>include/nori/bbox.h</code>.
</p>
<p>
Include the following in your report:
</p>
<ol>
<li>Explain the logic of your traversal function and justify its correctness.
(4 pts)</li>
<li>Measure the render time of the Ajax scene on your machine. How much of a
speed-up did you achieve over what was there before? You may need to slightly
reduce both the resolution and number of samples per pixel to obtain an estimate
of the time required by the brute force algorithm. This is based on the
reasonable assumption that the rendering time is proportional to the product of
the number of pixels and samples per pixel. But for a fair comparison, the
resolution should not be too low. Elaborate the configuration details you use
for comparison. (5 pts)
</li>
</ol>
</div>
<div class="alert alert-info" role="alert"><b>Hint</b>: You can use the the excellent <a href="https://github.com/Tom94/tev">tev</a> image viewer to view EXR image files. It is particularly useful to compare two images:
    <ol>
        <li>Open the two images in <code>tev</code> (e.g. from the command line or with drag-and-drop).</li>
        <li>With the first image selected, use <code>shift+click</code> to start comparing with the second image.</li>
        <li>You can select different metrics (absolute error, squared error, etc) and color-coding at the top of the sidebar.</li>
    </ol>
Once an image is open in <code>tev</code>, you can turn on the `watch` mode which automatically reloads the image when you render again with the same output filename.
</div>
<!-- ------------------------------------------------------------------------ -->
<h3>Part 3: Improved ray traversal <em>(15 points)</em></h3>
<div class="text-justify">
<p>
Modify your original implementation so that it performs an ordered traversal of
the child cells of an octree node from <em>closest</em> to <em>farthest</em>,
where distance is defined as the ray distance \(t\) of the closer intersection
between the ray and the bounding box of a child node. The function
<code>std::sort</code> may be helpful.

Note: when an intersection was previously found at a distance \(t_1\), it is
unnecessary to traverse a child cell with distance \(t_2>t_1\). This can be
used to prune away some parts of the tree.
</p>
<p>
Report the following information:
</p>
<ol>
<li>Include the surface normal visualization of the Ajax bust rendered by both
your basic and improved implementations. They should match perfectly.</li>
<li>How dit you implement the sorting? Explain your design choices. (2 pts)</li>
<li>Measure the render time with this improved version. How much of a speedup is
this relative to Part 2? Elaborate the configuration details you use for
comparison. (5 pts)</li>
</ol>
<!-- ------------------------------------------------------------------------ -->
<h3>Part 4: Efficiency <em>(40 points)</em></h3>
<div class="text-justify">
<p>
An efficient ray tracing implementation is essential in modern rendering
systems, and considerable care is taken to ensure that this operation runs as
fast as possible. A general rule of thumb is that expensive C++ operations
should never be used while tracing a ray (i.e. during octree traversal in your
case). This includes operations that perform dynamic memory allocation
(<code>malloc</code>, the <code>new</code> operator, or STL data structures that
internally perform dynamic memory allocation, such as
<code>std::vector</code>). Note that this doesn't mean that you can't use
<code>std::vector</code>s in your code--in fact, you will find many of them in
existing Nori code. However, a <code>std::vector</code> should never be created
*per ray* inside performance-critical ray traversal code.
</p>
<p>
    In this section, you will be required to enhance the efficiency of your
    octree code. A speed improvement of up to 10,000 times is achievable,
    although the exact amount may vary depending on your hardware. Your grade
    will be based on the level of efficiency improvement you achieve,
    categorized into specific groups. There is no need to push for the utmost
    limit of optimization as long as you achieve the highest efficiency
    category.
</p>
</div>

<h3>Bonus: Hacker Points <em>(5 points)</em></h3>

<div class="alert alert-danger" role="alert"><b>Disclaimer</b>: Hacker points
are “underpriced” bonus points for the daring few. Sometimes you might be
required to implement something that was not taught in class and you might have
to do some research and creative thinking. Hacker points are awarded only to
students who implemented the entire feature correctly, and they are added to
the final score of this assignment.
</div>
<div class="text-justify">
<p>
While the octree greatly accelerates ray tracing, its construction
unfortunately requires a considerable amount of time. What's worse is that all
of this time is spent in serial computations that just use a single processor.
However, the octree construction can clearly be parallelized: each subtree is independent
of all others and can be processed by an separate thread.
Find out how to use the Thread Building Blocks (TBB) library to benefit from
this kind of parallelism and realize this in your construction code.
Be sure to explain your design choices in the report and discuss performance
compared to the serial algorithm.
When submitting your assigment, please turn off any parallelism for us to grade previous parts.
</p>
</div>
</div>
